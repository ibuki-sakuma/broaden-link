# 始動時アクション
## 目的と原則
- セッション開始時に、プロジェクトの全体像を把握するため、以下の手順に基づきツール呼び出しの実行を提案します。
- 下記のアクションは、ユーザの指示に関わらず、優先的に実施します。
- **ユーザの承認を得ずに自発的**に全てのアクションを行い、ユーザの指示を問題なく実行できるレベルでプロジェクト全体を把握するよう心掛けて下さい。
- この期間中、エージェントは**ユーザーの入力プロンプトをアクティブにするようなテキスト出力を一切行いません**。これにより、ユーザーは全ての初期アクションが完了するまで返答できる状態になりません。

## 実行手順
1. **本指示書の完全な理解**: このドキュメント（`GEMINI.md`）の全内容を読み込み、ここに記載されたすべてのルール、手順、原則を完全に理解します。以降の全アクションは、この指示書の内容を厳密に遵守することを前提とします。
2. **ファイル構造の把握**: 現在のディレクトリツリーを再帰的に探索し、全ファイルの内容を読み込んで、プロジェクトの全体構造をコンテキストとして確立します。
3. **コミット履歴の分析**: `git log --oneline` を実行し、その出力結果からこれまでの開発履歴を把握します。これにより、プロジェクト全体の進行状況、方向性、コミットメッセージのスタイルといった「空気感」を理解します。
4. **セッション開始時の応答**: 手順1から3で得た情報を基に、以下の構造と要件を厳格に遵守した分析レポートを生成し、応答します。このレポートは、AIがプロジェクトのコンテキストを深く、かつ正確に理解したことを証明するものです。

## プロジェクトコンテキスト分析報告
```
指示に基づき、プロジェクトの解析を行いました。以下に現状の理解を報告します。

### 1. プロジェクト概要
- **目的とドメイン**: `README.md`やソースコード内のコメント、ディレクトリ構造から推測される、このプロジェクトの主目的、ターゲットユーザー、そして解決しようとしている課題を1〜2文で記述します。
- **技術スタック**:
  - **言語**: 主要言語と、検出されたその他言語をすべてリストアップします。
  - **フレームワーク/ライブラリ**: `package.json`、`Gemfile`、`requirements.txt`等の依存関係ファイルから特定した主要なフレームワークとライブラリを、その役割（例: `React (UI)`, `Express (Web Server)`)と共に列挙します。
  - **ツール/インフラ**: `Dockerfile`、`.github/workflows`、`webpack.config.js`、`tsconfig.json`等から特定したビルドツール、リンター、フォーマッター、CI/CD、コンテナ技術などをリストアップします。
- **プロジェクト規模**:
  - **ファイル総数**: プロジェクト全体のファイル数を報告します。
  - **コード行数**: 主要言語（例: TypeScript, Python）のソースコードの総行数を概算で報告します。

### 2. ファイル構造分析
- **ディレクトリ構成の役割**: 主要なディレクトリ（例: `src`, `lib`, `components`, `services`, `tests`, `docs`, `scripts`）をリストアップし、それぞれのディレクトリがプロジェクト内で担っている役割を具体的に説明します。
- **アーキテクチャの推測**: ディレクトリ構造とファイル間の依存関係から、採用されている可能性が高い設計思想やアーキテクチャパターン（例: MVC, レイヤードアーキテクチャ, コンポーネントベース, モノレポ）を、その根拠と共に提示します。
- **重要ファイルの特定**:
  - **エントリーポイント**: アプリケーションの起動点となるファイル（例: `src/index.ts`, `cmd/server/main.go`）を特定し、その役割を明記します。
  - **コアロジック**: プロジェクトの中核となるビジネスロジックが実装されていると判断した主要なファイルまたはディレクトリを挙げ、その理由を説明します。
  - **設定ファイル**: プロジェクトの挙動を定義する重要な設定ファイル（例: `.env.example`, `config/`ディレクトリ内のファイル）を特定し、その概要を説明します。

### 3. コミット履歴分析
- **直近の開発動向**: 最新のコミット5件を`git log --oneline`の形式でそのまま提示し、現在進行中のタスクや修正内容を具体的に要約します。
- **開発の方向性とフェーズ**:
  - **コミットメッセージの傾向**: コミットメッセージに特定の規約（例: Conventional Commits）が使用されているか、プレフィックス（`feat:`, `fix:`, `refactor:`等）の分布、メッセージの言語（日本語/英語）、粒度（詳細/簡潔）を分析し、開発スタイルを報告します。
  - **現在の開発フェーズの推測**: コミット履歴全体の傾向から、現在のプロジェクトが「新機能の積極的な開発」「リファクタリングによる品質改善」「バグ修正と安定化」「ドキュメント整備」など、どのフェーズにある可能性が高いかを、具体的なコミットを根拠として提示し、推測します。

### 4. 指示書の理解と次のステップ
- **遵守宣言**: 「`GEMINI.md`に記載された指示をすべて理解しました。これ以降の対話とタスク遂行において、これらのルールを厳格に遵守します。」と明記します。
- **アクションの確認**: 「以上の分析に基づき、どのようなタスクを始めますか？ 具体的な指示をお待ちしています。」と述べ、ユーザーからの指示を促します。
```

# 対話における遵守事項
本プロジェクトにおける全ての対話は、以下の原則に厳密に従って進行します。

* **指示の絶対性**: ユーザーからの最新の指示が最優先の命令です。過去の対話や自身の提案よりも、常に最新の指示に従います。指示されていないタスクの実行は一切行いません。
* **計画的な問題解決**: 同一タスクで複数回失敗した場合、闇雲な試行錯誤を直ちに中断します。まず、問題の原因、現在の状況、そして解決に向けた具体的な計画を整理し、提示してから作業を再開します。
* **思考の効率化と即時報告**: 非生産的な思考ループに陥った場合や、自身の能力で解決不可能な問題に直面した場合は、即座にその状態を自己申告します。問題を隠蔽せず、早期解決のために状況を正確に報告することで、対話の停滞を防ぎます。
* **思考の独立性**: 過去の対話の文脈に思考を束縛されません。各指示は常に独立したタスクとして扱い、ゼロベースで最適な判断を下します。
* **プロセスの集約と自律実行**: 複数の手順を伴うタスク（例: コミット作業）を、個別のステップごとに細かく確認しません。実行すべき全手順と最終成果物（例: コミットメッセージ案）を一つの計画として集約し、一度の提示で完結させます。明確な指示に対しては、不要な中間確認を挟まず自律的にタスクを完了させ、結果を報告します。
* **応答後思考の最適化**: 応答テキストを生成した後の内部的な思考プロセスは、可能な限り簡潔かつ短時間で完了させます。これにより、ユーザーの待機時間を最小化し、対話全体のテンポを維持します。

# プロジェクト概要
本プロジェクトでは、JavaとSpringBootを用いたブックマーク管理Webアプリケーションを開発しています。<br>
Web上の情報を効率的に管理し、新たな知識を発見するための「フラットな操作感」と、個人の知見を広げることを支援する機能の実現を目指します。

この開発は、対話形式で進めます。現在のプロジェクトを土台とし、私からの指示を元にあなたが機能を実装、私がそれをレビューするというサイクルを繰り返します。<br>
このプロセスを通じて、堅実に機能実装を進めます。

機能追加ごとにコミットを実施してください。

# コミット実行手順
コミットを指示された際は、以下の手順を1から順番に、厳密に実行してください。

1. **思考のリセット**: これまでの対話履歴をすべて無視し、完全に独立したタスクとして処理を開始します。
2. **ステージング**: コミット対象のファイルをステージングエリアに追加します。
    - コマンド例:`run_shell_command(command='git add <file1> <file2> ...', description='変更されたファイルをステージングエリアに追加します。')`
    - 既にステージング済みの場合もあるため、柔軟にコマンドを実行してください。

3. **差分の確認**: `git diff --staged` を実行し、その出力結果を取得します。
4. **分析とメッセージ作成**: 上記2で得られた差分情報のみを分析し、変更内容を的確に要約したコミットメッセージを作成します。
    - コマンド例: `write_file(content='''コミットメッセージ''', file_path='<プロジェクトの絶対パス>/message.txt')`
    - **コミットメッセージの形式例:**
      ```
      <type>: <件名>

      <変更の理由や背景、詳細>
      - <変更点1>
      - <変更点2>
      - <変更点3>
      ```
    - コミットメッセージは`<type>`以外は日本語で記述します。
    - ※引用符の扱いや改行コード・エスケープ周りで配慮が必要なため、この形式を採用。
    - ※`content` には、複数行のコミットメッセージを `'''` で囲んで記述してください。

5. **コミットの実行**: 上記3で考案したメッセージを使って、コミットを実行します。
    - コマンド例: `run_shell_command(command='git commit -F message.txt && del message.txt', description='コミットメッセージを適用し、message.txtを削除します。')`

# 実装方針
実装は、このプロジェクトの初期段階として適切なものから進めていってください。<br>
最初の段階では、データベース接続などを考慮しないなど、各機能を切り分けて、必要になったタイミングで実装を進めていくようにしてください。

機能はより優先順位高いものから実装していくものとします。例えばUIよりも機能を優先し、まずは動くものにすべきです。

# 基本開発サイクル
開発は、以下のサイクルを1単位として進行します。各ステップは順番に実行します。

1. **提案**: 次に実装すべき機能や修正内容を具体的に提案します。
2. **承認**: 提案内容についてユーザーの承認を得ます。承認なしに実装は開始しません。
3. **実装**: 承認された仕様に基づき、コード実装を行います。
4. **検証**: 実装が完了したらその結果を提示し、ユーザーによるレビューを受けます。
5. **完了とコミット**: 全ての検証で問題がなければ、その機能単位の開発は完了とします。その後、指示に従い「コミット実行手順」に沿ってコミットを実行します。

# ファイルパス指定に関する注意点
コマンドでファイルパスを指定する際は、**絶対パス**を**ダブルクォーテーション**で囲んで指定してください。
- コマンド例１: `tool_name(file_path="<絶対パス>/file.txt")`
- コマンド例２: `tool_name(path="<絶対パス>/directory/")`

# 開発の全体方針とインフラ・UI/UXに関する検討事項
これはプロジェクト全体の方向性を示すものであり、特定の機能実装の優先順位とは異なります。

## UI/UXの方向性:
- おしゃれすぎず、企業向けシステムのようなシンプルなデザインを目指す。
- 過度な装飾を避け、視認性と操作性を重視したクリーンなレイアウトを心がける。
- レスポンシブデザインを考慮し、様々なデバイスでの表示に対応する。
- アクセシビリティ（十分なコントラスト比、キーボードナビゲーションなど）にも配慮する。

## 開発プロセスとインフラ:
- **ブランチ戦略:** 本番環境用のブランチを少なくとも作成する。その他のブランチ運用については、現時点では未定とし、プロジェクトの進捗に応じて柔軟に決定する。
  - mainブランチを本番環境用として運用。
  - 機能開発はdevelopブランチで行う。
- **CI/CD:** GitHubと連携し、GitHub Actionsを用いたCI/CDパイプラインの構築を検討する。
  - GitHub Actionsを用いてCI/CDパイプラインを構築済み。
  - ファイル: `.github/workflows/main.yml`
- **ホスティング:** 適切なホスティングサービスを選定する。
  - AWS上でホスティング済み。
  - AWS ECS (EC2起動タイプ) 上でコンテナとして実行。
- **データベース:** 必要に応じて、開発/テスト/本番環境でのDB分離や、サービスに応じたDB分割を検討する。
  - 開発/テスト:H2とdockerコンテナ（postgresql）
  - 本番: RDS（postgresql）を利用。
- **AI活用:** AIを活用したテスト実行サービス（例: テストケース自動生成、テスト結果分析など）の導入を検討する。
  - 現状：検討中
- **コンテナ化:** Dockerの導入を検討し、開発環境の統一やデプロイの簡素化を図る。
  - Dockerを導入済み。
  - ファイル: `Dockerfile`, `docker-compose.yml`

## 全体的な目標:
- 堅牢性、拡張性、保守性を備えた、スタンダードなアーキテクチャの構築を目指す。
